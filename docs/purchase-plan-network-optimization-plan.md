# План оптимизации сетевых запросов при открытии плана закупок

## Текущие запросы при открытии страницы (порядок и источник)

| № | Запрос | Источник | Назначение |
|---|--------|----------|------------|
| 1 | `GET /api/auth/check` | AuthContext (глобально) | Проверка авторизации |
| 2 | `GET /api/cfos/names?for=purchase-plan-items` | usePurchasePlanItemsFilters | Список ЦФО для фильтров |
| 3 | `GET /api/purchase-plan-items/unique-values` | usePurchasePlanItemsFilters | Уникальные значения для фильтров (company, purchaser, status и т.д.) |
| 4 | `GET /api/users?page=0&size=1000` | usePurchasePlanItemsEditing | Список пользователей для выбора закупщика (dropdown) |
| 5 | `GET /api/purchase-plan-items/years` | usePurchasePlanItemsTable | Доступные годы для селектора года |
| 6 | `GET /api/purchase-plan-items?page=0&size=1` | usePurchasePlanItemsTable (fetchTotalRecords) | Общее количество записей для пагинации |
| 7 | `GET /api/purchase-plan-items?page=0&size=100&year=2026&...` | usePurchasePlanItemsTable (fetchData) | Основные данные таблицы (первая страница) |
| 8 | `GET /api/purchase-plan-versions/year/2026` | loadVersions(selectedYear) | Список версий плана на выбранный год |
| 9 | `GET /api/purchase-requests/by-id-purchase-request-list?idPurchaseRequest=...` | fetchData (внутри) | Статусы заявок для строк таблицы |
| 10 | `GET /api/purchase-plan-items?page=0&size=10000&...` | fetchChartData | Данные для графика по месяцам (до 10 000 записей) |
| 11 | `GET /api/purchase-plan-items/purchaser-summary?year=2026&...` | fetchSummaryData | Сводная таблица по закупщикам (агрегат) |

---

## Проблемы и возможности оптимизации

### 1. Лишний запрос: `page=0&size=1` (общее количество)

**Проблема:** Отдельный запрос только ради `totalElements` дублирует логику основного запроса. При этом основной запрос `page=0&size=100&year=2026&...` уже возвращает `totalElements` для тех же фильтров. Запрос `size=1` в текущей реализации без года/фильтров даёт «общее» число по всей БД, тогда как в UI нужно показывать количество с учётом фильтров (год, статус и т.д.) — то есть как раз `data.totalElements` из основного ответа.

**Рекомендация:** Убрать отдельный запрос за total. Использовать только `data.totalElements` из основного запроса. До первой загрузки показывать «0 из 0» или «Загрузка…».

**Файлы:** `frontend/src/app/purchase-plan/_components/hooks/usePurchasePlanItemsTable.ts` — удалить эффект с `fetchTotalRecords` и вызов `fetch(/api/purchase-plan-items?page=0&size=1)`; инициализировать `totalRecords` из `data.totalElements` (уже делается в `fetchData`).

**Эффект:** −1 запрос при каждом открытии и при смене фильтров.

---

### 2. Тяжёлый и избыточный запрос: `size=10000` для графика

**Проблема:** Для графика по месяцам загружаются до 10 000 записей, хотя для отрисовки нужны только агрегированные счётчики по месяцам (14 значений: декабрь прошлого года + 12 месяцев + «без даты»).

**Рекомендация:** Ввести на бэкенде эндпоинт агрегации, например:
- `GET /api/purchase-plan-items/monthly-distribution?year=2026&...` (те же query-параметры, что у списка),
- ответ: `{ "monthCounts": [ n0, n1, ..., n13 ] }` или массив `{ monthKey, count }`.

Фронт: убрать `fetchChartData` с `size=10000`, вызывать новый эндпоинт и передавать результат в логику графика (getMonthlyDistribution).

**Файлы:**  
- Backend: новый метод в сервисе/контроллере плана закупок, расчёт распределения по месяцам (например, через JPA Criteria или один SQL с GROUP BY).  
- Frontend: `usePurchasePlanItemsTable.ts` — заменить вызов списка с size=10000 на вызов monthly-distribution, обновить обработку в getMonthlyDistribution.

**Эффект:** Сильное снижение объёма данных (десятки байт вместо тысяч записей), быстрее ответ и меньше нагрузка на БД.

---

### 3. Загрузка 1000 пользователей при открытии страницы

**Проблема:** `GET /api/users?page=0&size=1000` выполняется при монтировании компонента (usePurchasePlanItemsEditing), хотя список пользователей нужен только при открытии модалки создания/редактирования или фильтра «Закупщик».

**Рекомендация:** Отложенная загрузка:
- Загружать пользователей при первом открытии модалки создания/редактирования позиции плана или при первом открытии фильтра «Закупщик».
- Либо использовать существующий поиск пользователей (если есть эндпоинт с `?name=` / `?search=`) с небольшим размером страницы и подгружать по вводу в dropdown.

**Файлы:** `frontend/src/app/purchase-plan/_components/hooks/usePurchasePlanItemsEditing.ts` — убрать загрузку пользователей из `useEffect` при монтировании; вызывать загрузку при открытии модалки/фильтра (например, по флагу `isCreateModalOpen` или при первом фокусе на поле закупщика). Проверить, есть ли на бэкенде поиск пользователей с пагинацией.

**Эффект:** −1 тяжёлый запрос при открытии страницы; пользователи подгружаются только когда нужны.

---

### 4. Параллелизация и порядок запросов

**Текущее состояние:**  
- Годы загружаются в одном эффекте, после них выбирается год и запускаются `fetchData`, `loadVersions`, затем после ответа `fetchData` — запрос статусов заявок, затем (после `loading=false`) — fetchChartData и fetchSummaryData.  
- Фильтры: cfos + unique-values уже запрашиваются параллельно через `Promise.all`.

**Рекомендации:**
- Запрос версий `purchase-plan-versions/year/{year}` можно вызывать сразу после того, как известен год (уже так и есть), оставить как есть.
- После внедрения пунктов 1–3 часть запросов исчезнет; оставшиеся можно по возможности не блокировать друг другом (например, не ждать завершения графика для отображения таблицы — уже так и есть).

Дополнительно: при наличии на бэкенде возможности отдавать в одном ответе и список позиций, и распределение по месяцам — можно объединить в один запрос (сложнее, делать только при необходимости).

---

### 5. Запрос статусов заявок: `by-id-purchase-request-list`

**Проблема:** После получения страницы позиций плана (100 шт.) отправляется один запрос со списком id заявок для подстановки статусов в таблицу. Объём данных небольшой, но лишний round-trip.

**Рекомендация (опционально):** Рассмотреть на бэкенде вариант, когда ответ `GET /api/purchase-plan-items` уже включает поле статуса заявки (например, через join или подзапрос). Тогда отдельный запрос `by-id-purchase-request-list` не нужен. Требует изменения API и маппинга на бэкенде.

**Эффект:** −1 запрос при каждой загрузке страницы таблицы.

---

## Приоритеты внедрения

| Приоритет | Задача | Сложность | Эффект |
|-----------|--------|-----------|--------|
| 1 | Убрать запрос `page=0&size=1` (total), использовать только `data.totalElements` | Низкая | −1 запрос, проще логика |
| 2 | Эндпоинт monthly-distribution, убрать fetchChartData с size=10000 | Средняя (бэкенд + фронт) | −1 тяжёлый запрос, сильно меньше данных |
| 3 | Lazy-load списка пользователей (при открытии модалки/фильтра) | Низкая/средняя | −1 запрос при открытии страницы |
| 4 | (Опционально) Включить статус заявки в ответ purchase-plan-items | Средняя | −1 запрос на каждую загрузку страницы |

---

## Ожидаемый результат после оптимизаций

- **Было:** 11 запросов при открытии плана закупок, среди них один с size=10000 и один с size=1000.  
- **После 1:** 10 запросов.  
- **После 1+2:** 9 запросов, без передачи больших списков для графика.  
- **После 1+2+3:** 8 запросов при открытии; пользователи подгружаются по требованию.  
- **После 1+2+3+4:** 7 запросов (если бэкенд отдаёт статус заявки в основном ответе).

---

## Чек-лист по пунктам

- [x] Удалить эффект fetchTotalRecords, использовать только data.totalElements в usePurchasePlanItemsTable.
- [x] Backend: добавить GET /api/purchase-plan-items/monthly-distribution с теми же фильтрами, вернуть monthCounts.
- [x] Frontend: заменить fetchChartData (size=10000) на вызов monthly-distribution, обновить getMonthlyDistribution.
- [x] Перенести загрузку пользователей в usePurchasePlanItemsEditing на момент открытия модалки/редактирования закупщика (loadUsersIfNeeded).
- [ ] (Опционально) Backend: добавить в ответ purchase-plan-items поле статуса заявки; фронт: убрать вызов by-id-purchase-request-list из fetchData.
