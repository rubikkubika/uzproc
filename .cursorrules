# Правила для Cursor AI

## Использование терминала

**КРИТИЧЕСКИ ВАЖНО:** Для всех терминальных команд использовать Git Bash в первую очередь, а не PowerShell или CMD.

### Правила:

1. **Все команды должны выполняться через Git Bash:**
   - Использовать синтаксис bash для всех команд
   - Использовать Unix-подобные команды (`pkill`, `kill`, `lsof`, `curl` и т.д.)
   - Использовать bash-синтаксис для условных операций (`||`, `&&`, `2>/dev/null`)

2. **Правильный способ запуска Git Bash из PowerShell:**
   
   Когда терминал по умолчанию - PowerShell (Windows), использовать следующий синтаксис для вызова Git Bash:
   ```powershell
   # Вызов Git Bash с одной командой
   & "C:\Program Files\Git\bin\bash.exe" -c "команда"
   
   # Вызов Git Bash с несколькими командами
   & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
   
   # Примеры правильных команд для остановки процессов:
   & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'spring-boot:run' || true"
   & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:8080) 2>/dev/null || true"
   
   # Примеры правильных команд для запуска:
   & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
   & "C:\Program Files\Git\bin\bash.exe" -c "sleep 15 && curl http://localhost:8080/api/health"
   ```
   
   **Важно:** 
   - Использовать `&` для вызова команды в PowerShell
   - Путь к Git Bash может отличаться, стандартный путь: `C:\Program Files\Git\bin\bash.exe`
   - Для переменных в bash командах использовать обратные кавычки: `` `$var `` вместо `$var`
   - Для строк в bash командах использовать одинарные кавычки: `'строка'`

3. **Примеры правильных команд (если терминал уже Git Bash):**
   ```bash
   # Остановка процессов
   pkill -f "spring-boot:run" || true
   kill -9 $(lsof -ti:8080) 2>/dev/null || true
   
   # Проверка портов
   lsof -ti:8080
   
   # Запуск сервисов
   cd backend && mvn spring-boot:run
   ```

4. **НЕ использовать:**
   - PowerShell команды (`Get-Process`, `Get-NetTCPConnection`, `Stop-Process` и т.д.) - только если Git Bash недоступен
   - CMD команды (`taskkill`, `netstat` и т.д.)
   - Windows-специфичные команды напрямую

5. **Исключения:**
   - PowerShell скрипты для деплоя (`scripts/deploy-simple.ps1`) остаются без изменений, так как они специально созданы для PowerShell
   - Docker команды (`docker compose`) работают одинаково в bash и PowerShell
   - Если Git Bash недоступен или не установлен, можно использовать PowerShell команды как запасной вариант

**ВАЖНО:** 
- Все новые команды должны быть написаны для Git Bash в первую очередь
- При работе в PowerShell использовать правильный синтаксис вызова Git Bash: `& "C:\Program Files\Git\bin\bash.exe" -c "команда"`
- Если терминал уже Git Bash, использовать команды напрямую без обертки

## Деплой на сервер
Когда пользователь упоминает "деплой", "deploy", "опубликовать", "публикация", "выложить на сервер" или похожие фразы, необходимо автоматически выполнить скрипт деплоя:

1. Выполнить PowerShell скрипт `scripts/deploy-simple.ps1` из корня проекта
2. Скрипт автоматически:
   - Соберет Docker образы (frontend, backend)
   - Сохранит их в tar файлы
   - Скопирует образы и `docker-compose.yml` на сервер (devops@10.123.48.62)
   - Обновит контейнеры на сервере

**ВАЖНО:** При деплое обязательно копировать обновленный `docker-compose.yml` на сервер, чтобы конфигурация сервисов была актуальной.

**КРИТИЧЕСКИ ВАЖНО:** При деплое НИКОГДА не выполнять коммит (`git commit`) и пуш (`git push`) изменений в Git, если пользователь явно не просит об этом. Деплой выполняется только через скрипт, без изменений в репозитории. Даже если есть незакоммиченные изменения, их НЕ нужно коммитить и пушить автоматически при деплое.

Команда для выполнения:
```powershell
.\scripts\deploy-simple.ps1
```

Не нужно спрашивать подтверждение - просто выполнить скрипт при упоминании деплоя.

## Запуск сервисов
Когда пользователь просит запустить сервис (фронтенд, бэкенд или оба), необходимо автоматически:

1. **Проверить и остановить локальные процессы:**
   - Проверить наличие запущенных Java процессов (для бэкенда)
   - Проверить наличие запущенных Node.js процессов (для фронтенда)
   - Остановить найденные процессы перед запуском

2. **Проверить и остановить Docker контейнеры:**
   - Проверить статус контейнеров через `docker compose ps`
   - Остановить и удалить существующие контейнеры через `docker compose stop` и `docker compose rm -f`
   - Это нужно делать для всех сервисов (frontend, backend, postgres)

3. **Запустить сервисы:**
   - После очистки запустить нужные сервисы через `docker compose up -d` или локально, в зависимости от запроса пользователя

Примеры фраз, которые должны триггерить это правило:
- "запусти сервис"
- "запусти бэкенд"
- "запусти фронтенд"
- "запусти локально"
- "запусти в докере"
- "перезапусти сервис"
- "перезапусти бэкенд"
- и похожие запросы

Не нужно спрашивать подтверждение - автоматически проверять и останавливать существующие процессы/контейнеры перед запуском.

## Локальный запуск без Docker

Когда пользователь просит запустить сервисы локально без Docker ("запусти локально без докера", "запусти без docker" и т.д.), необходимо:

### Подготовка окружения

1. **Для фронтенда:**
   - **macOS (с nvm):** Загрузить nvm: `source ~/.nvm/nvm.sh` (если npm не в PATH)
   - **Windows:** Убедиться, что Node.js установлен и доступен в PATH
   - Проверить npm: `npm --version` (работает на обеих платформах)

2. **Для бэкенда:**
   - **macOS/Linux:** Проверить Maven: `which mvn` или `mvn --version`
   - **Windows:** Проверить Maven: `where mvn` или `mvn --version`
   - Убедиться, что Java 17+ установлена: `java -version` (работает на всех платформах)

### Запуск PostgreSQL

PostgreSQL должен быть запущен в Docker (инфраструктура):
```bash
docker compose up -d postgres
```

### Запуск фронтенда

1. **Остановить существующие процессы:**
   - **macOS/Linux (Git Bash):**
     ```bash
     pkill -f "next dev" || true
     kill -9 $(lsof -ti:3000) 2>/dev/null || true
     ```
   - **Windows (PowerShell с вызовом Git Bash):**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'next dev' || true"
     & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:3000) 2>/dev/null || true"
     ```
   - **Windows (если Git Bash недоступен, запасной вариант):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*node*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 3000 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```

2. **Запустить фронтенд:**
   - **Если терминал Git Bash:**
     ```bash
     cd frontend && npm run dev
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "cd frontend && npm run dev"
     ```
   - Фронтенд будет доступен на http://localhost:3000
   - Скрипты в `package.json` используют стандартные команды (`next dev`), которые работают на Mac и Windows

### Запуск бэкенда

1. **Остановить существующие процессы:**
   - **macOS/Linux (Git Bash):**
     ```bash
     pkill -f "spring-boot:run" || true
     kill -9 $(lsof -ti:8080) 2>/dev/null || true
     ```
   - **Windows (PowerShell с вызовом Git Bash):**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'spring-boot:run' || true"
     & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:8080) 2>/dev/null || true"
     ```
   - **Windows (если Git Bash недоступен, запасной вариант):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*java*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 8080 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```

2. **Запустить бэкенд:**
   - **Если терминал Git Bash:**
     ```bash
     cd backend && mvn spring-boot:run
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
     ```
   - Бэкенд будет доступен на http://localhost:8080/api
   - Health check: http://localhost:8080/api/health
   - Команда `mvn spring-boot:run` работает одинаково на всех платформах

### Проверка статуса

После запуска проверить:
- **Фронтенд:**
  - macOS/Linux (Git Bash): `curl http://localhost:3000` (ожидается HTTP 307 или 200)
  - Windows (PowerShell с Git Bash): `& "C:\Program Files\Git\bin\bash.exe" -c "curl http://localhost:3000"`
  - Windows (запасной вариант): `Invoke-WebRequest http://localhost:3000` (PowerShell)
- **Бэкенд:**
  - macOS/Linux (Git Bash): `curl http://localhost:8080/api/health` (ожидается `{"service":"uzproc-backend","status":"UP"}`)
  - Windows (PowerShell с Git Bash): `& "C:\Program Files\Git\bin\bash.exe" -c "curl http://localhost:8080/api/health"`
  - Windows (запасной вариант): `Invoke-WebRequest http://localhost:8080/api/health` (PowerShell)

### Важные замечания

- **npm должен быть в PATH:**
  - macOS: настроено через `.bash_profile` и `.zshrc` для автоматической загрузки nvm
  - Windows: Node.js должен быть установлен и добавлен в PATH системы (обычно делается автоматически при установке)
- PostgreSQL запускается в Docker, так как это инфраструктура (команда `docker compose up -d postgres` работает одинаково на всех платформах)
- При перезапуске всегда останавливать старые процессы перед запуском новых (использовать Git Bash команды в первую очередь)
- Запускать сервисы в фоновом режиме (`is_background: true`) или с перенаправлением вывода для логирования
- **На Windows использовать Git Bash через PowerShell:** `& "C:\Program Files\Git\bin\bash.exe" -c "команда"`

## Создание скриптов
НЕ создавать скрипты (shell, PowerShell, bash и т.д.) автоматически, если пользователь явно не запросил создание скрипта. Создавать скрипты только когда пользователь явно просит:
- "создай скрипт"
- "напиши скрипт"
- "сделай скрипт"
- "автоматизируй через скрипт"
- или похожие явные запросы

Если задача может быть решена без скрипта (например, через прямые команды или изменения в коде), не предлагать и не создавать скрипты.

## Документация
Всю документацию (README.md, инструкции, руководства, API документацию и т.д.) необходимо хранить в папке `docs` в корне проекта. 

- README файлы для отдельных модулей (например, `backend/README.md`, `frontend/README.md`) можно оставлять в соответствующих папках
- Общую документацию проекта, инструкции по развертыванию, архитектурные решения и другую проектную документацию размещать в `docs/`
- При создании новой документации предлагать размещение в `docs/`, если это не специфичный README для модуля

## Добавление новых полей и парсинг Excel

При добавлении новых полей в сущность `PurchaseRequest` и их парсинга из Excel файлов, **ОБЯЗАТЕЛЬНО** нужно:

1. **Изучить существующие поля и их парсинг:**
   - Посмотреть, как парсятся другие опциональные поля (например, `cfo`, `name`, `title`, `innerId`) в методе `parsePurchaseRequestRow` класса `ExcelLoadService`
   - Использовать аналогичную логику и структуру кода
   - Следовать тем же паттернам и стилю кода

2. **Добавить константу для названия колонки:**
   - Добавить `private static final String NEW_FIELD_COLUMN = "Название колонки в Excel";` в начало класса `ExcelLoadService`
   - Использовать точное название колонки из Excel файла

3. **Найти колонку в заголовке:**
   - Использовать `findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN)` для поиска колонки
   - Если колонка может иметь альтернативные названия, добавить проверки с `findColumnIndex` для каждого варианта
   - Добавить логирование, если колонка не найдена (как для других полей)

4. **Парсинг значения:**
   - Для строковых полей: использовать `getCellValueAsString(cell)` и проверку на `null` и пустоту
   - Для булевых полей: использовать `parseBooleanCell(cell)` и проверку на `null`
   - Для числовых полей: использовать соответствующие методы парсинга (`parseLongCell`, `parseDateCell` и т.д.)
   - Следовать той же структуре проверок, что и для других полей

5. **Обновление существующих записей:**
   - Добавить логику обновления нового поля в метод `updatePurchaseRequestFields`
   - Использовать тот же паттерн проверки на изменения, что и для других полей
   - Добавить логирование обновлений

6. **Пример структуры для опционального строкового поля:**
   ```java
   // В методе loadPurchaseRequestsFromExcel:
   Integer newFieldColumnIndex = findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN);
   
   // В методе parsePurchaseRequestRow:
   if (newFieldColumnIndex != null) {
       Cell newFieldCell = row.getCell(newFieldColumnIndex);
       String newField = getCellValueAsString(newFieldCell);
       if (newField != null && !newField.trim().isEmpty()) {
           pr.setNewField(newField.trim());
       }
   }
   
   // В методе updatePurchaseRequestFields:
   if (newData.getNewField() != null && !newData.getNewField().trim().isEmpty()) {
       if (existing.getNewField() == null || !existing.getNewField().equals(newData.getNewField())) {
           existing.setNewField(newData.getNewField());
           updated = true;
           logger.debug("Updated newField for request {}: {}", existing.getIdPurchaseRequest(), newData.getNewField());
       }
   }
   ```

7. **Для булевых полей с обратной логикой:**
   - Если колонка называется "Не требуется..." или имеет обратную логику, проверить название колонки
   - Передать название колонки в метод `parsePurchaseRequestRow` как дополнительный параметр
   - Инвертировать логику парсинга, если необходимо

**ВАЖНО:** Всегда смотреть на существующие поля и делать аналогично. Не изобретать новые подходы, если уже есть рабочие примеры в коде.

## Автоматический перезапуск бэкенда после изменений

Когда вносятся изменения в код бэкенда (Java файлы в `backend/src/main/java/`), **ОБЯЗАТЕЛЬНО** нужно автоматически перезапустить бэкенд локально без Docker после завершения изменений.

### Процесс перезапуска:

1. **Остановить существующие процессы бэкенда:**
   - **macOS/Linux (Git Bash):**
     ```bash
     pkill -f "spring-boot:run" || true
     kill -9 $(lsof -ti:8080) 2>/dev/null || true
     ```
   - **Windows (PowerShell с вызовом Git Bash):**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'spring-boot:run' || true"
     & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:8080) 2>/dev/null || true"
     ```
   - **Windows (если Git Bash недоступен, запасной вариант):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*java*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 8080 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```

2. **Запустить бэкенд:**
   - **Если терминал Git Bash:**
     ```bash
     cd backend && mvn spring-boot:run
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
     ```
   - Запускать в фоновом режиме (`is_background: true`)

3. **Проверить, что бэкенд запустился:**
   - Подождать 15-20 секунд после запуска
   - **Если терминал Git Bash:**
     ```bash
     curl http://localhost:8080/api/health
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "curl http://localhost:8080/api/health"
     ```
   - Ожидается ответ: `{"service":"uzproc-backend","status":"UP"}`

### Когда перезапускать:

Перезапуск необходим после изменений в:
- Java классах (entity, controller, service, repository и т.д.)
- Конфигурационных файлах (`application.yml`, `application.properties`)
- Миграциях Flyway (после создания новой миграции)
- Любых других файлах в `backend/src/main/`

### Исключения:

- Изменения только во фронтенде (`frontend/`) - перезапуск бэкенда не требуется
- Изменения только в документации или README - перезапуск не требуется
- Изменения только в Docker файлах (`docker/`, `docker-compose.yml`) - перезапуск не требуется (если не используется Docker)

**ВАЖНО:** Не спрашивать подтверждение у пользователя - автоматически перезапускать бэкенд после изменений в коде бэкенда.

## Фильтрация данных на бэкенде

**КРИТИЧЕСКИ ВАЖНО:** Если данные получаются с бэкенда в отфильтрованном виде, то **ВСЯ фильтрация должна выполняться на бэкенде**, а не на клиенте.

### Правила:

1. **Все фильтры должны применяться на бэкенде:**
   - Фильтры по полям сущности (год, ЦФО, инициатор, название и т.д.) должны передаваться как параметры запроса на бэкенд
   - Бэкенд должен применять все фильтры через JPA Specification или аналогичный механизм
   - Пагинация должна применяться на бэкенде **ПОСЛЕ** применения всех фильтров

2. **Клиентская фильтрация допустима ТОЛЬКО если:**
   - Фильтрация основана на данных, которых нет в сущности на бэкенде (например, вычисляемые поля, агрегированные данные)
   - И это явно указано в комментариях с объяснением причины
   - В этом случае клиентская фильтрация должна применяться **ПЕРЕД** пагинацией, и пагинация должна применяться к уже отфильтрованным данным

3. **Пагинация:**
   - Пагинация всегда должна учитывать все примененные фильтры
   - Если фильтры применяются на бэкенде - пагинация тоже на бэкенде
   - Если фильтры применяются на клиенте - пагинация применяется к отфильтрованным данным на клиенте
   - `totalElements` и `totalPages` должны отражать количество записей **после** применения всех фильтров

4. **Множественный выбор:**
   - Для множественного выбора (например, несколько ЦФО) использовать массив параметров или список значений
   - На бэкенде использовать `IN` запрос или `OR` условия для множественного выбора

5. **Проверка:**
   - При реализации фильтрации всегда проверять, что пагинация учитывает все фильтры
   - Убедиться, что `totalElements` соответствует количеству отфильтрованных записей, а не всех записей в базе

**Пример правильной реализации:**
- Фронтенд передает все параметры фильтрации на бэкенд
- Бэкенд применяет все фильтры через Specification
- Бэкенд применяет пагинацию к отфильтрованным данным
- Бэкенд возвращает `Page` с правильными `totalElements` и `totalPages`
- Фронтенд использует данные напрямую без дополнительной фильтрации

## Разделение ответственности: Контроллеры и Сервисы

**КРИТИЧЕСКИ ВАЖНО:** При создании нового контроллера **ОБЯЗАТЕЛЬНО** нужно создать соответствующий сервисный слой. Вся бизнес-логика должна находиться в сервисах, контроллеры должны только обрабатывать HTTP-запросы.

### Правило при создании новых контроллеров:

1. **Всегда создавать сервис перед контроллером:**
   - При создании нового контроллера сначала создать соответствующий сервис
   - Контроллер должен только вызывать методы сервиса
   - Вся логика работы с данными, валидация, бизнес-правила - в сервисе

2. **Структура создания:**
   ```
   1. Создать Entity (если еще нет)
   2. Создать Repository (если еще нет)
   3. Создать Service с бизнес-логикой
   4. Создать Controller, который использует Service
   ```

3. **Пример правильного подхода:**
   ```java
   // ✅ ПРАВИЛЬНО: Сначала сервис
   @Service
   @Transactional(readOnly = true)
   public class NewEntityService {
       private final NewEntityRepository repository;
       
       public List<NewEntity> findAll() {
           // Вся логика здесь
           return repository.findAll();
       }
   }
   
   // Затем контроллер
   @RestController
   @RequestMapping("/api/new-entities")
   public class NewEntityController {
       private final NewEntityService service;
       
       @GetMapping
       public ResponseEntity<List<NewEntity>> getAll() {
           return ResponseEntity.ok(service.findAll());
       }
   }
   ```

4. **Что НЕ делать:**
   ```java
   // ❌ НЕПРАВИЛЬНО: Логика в контроллере
   @RestController
   @RequestMapping("/api/new-entities")
   public class NewEntityController {
       private final NewEntityRepository repository; // ❌ Прямая работа с репозиторием
       
       @GetMapping
       public ResponseEntity<List<NewEntity>> getAll() {
           // ❌ Логика в контроллере
           return ResponseEntity.ok(repository.findAll());
       }
   }
   ```

### Правила для контроллеров:

1. **Контроллеры должны быть тонкими:**
   - Принимать HTTP-запросы и параметры
   - Вызывать методы сервисов
   - Возвращать HTTP-ответы (ResponseEntity)
   - Обрабатывать HTTP-специфичные вещи (коды статусов, заголовки)

2. **Контроллеры НЕ должны содержать:**
   - Бизнес-логику
   - Построение запросов к базе данных (Specification, Query)
   - Валидацию данных (кроме базовой проверки на null)
   - Обработку файлов (кроме получения MultipartFile)
   - Сложные вычисления или преобразования данных
   - Прямую работу с репозиториями (только через сервисы)

3. **Что допустимо в контроллерах:**
   - Маппинг параметров запроса в параметры методов сервисов
   - Определение HTTP-кодов ответов на основе результатов сервисов
   - Простая проверка на null перед вызовом сервиса
   - Логирование HTTP-запросов (но не бизнес-логики)

### Правила для сервисов:

1. **Сервисы содержат всю бизнес-логику:**
   - Построение запросов к базе данных (Specification, Query)
   - Фильтрация, сортировка, пагинация
   - Валидация данных
   - Обработка файлов
   - Преобразование данных
   - Работа с репозиториями
   - Сложные вычисления

2. **Сервисы должны быть:**
   - Помечены аннотацией `@Service`
   - Использовать `@Transactional` для операций с базой данных
   - Содержать логирование бизнес-логики
   - Быть независимыми от HTTP-слоя

3. **Структура сервиса:**
   ```java
   @Service
   @Transactional(readOnly = true) // для read-only операций
   public class EntityService {
       private final EntityRepository repository;
       
       public Page<Entity> findAll(...) {
           // Вся логика фильтрации, сортировки, пагинации
       }
       
       public Entity findById(Long id) {
           // Логика поиска
       }
   }
   ```

### Примеры правильной реализации:

**Правильно (контроллер):**
```java
@RestController
@RequestMapping("/entities")
public class EntityController {
    private final EntityService entityService;
    
    @GetMapping
    public ResponseEntity<Page<Entity>> getAll(
            @RequestParam int page,
            @RequestParam int size) {
        Page<Entity> entities = entityService.findAll(page, size);
        return ResponseEntity.ok(entities);
    }
}
```

**Неправильно (логика в контроллере):**
```java
@RestController
@RequestMapping("/entities")
public class EntityController {
    private final EntityRepository repository;
    
    @GetMapping
    public ResponseEntity<Page<Entity>> getAll(...) {
        // ❌ НЕПРАВИЛЬНО: построение Specification в контроллере
        Specification<Entity> spec = (root, query, cb) -> { ... };
        Page<Entity> entities = repository.findAll(spec, pageable);
        return ResponseEntity.ok(entities);
    }
}
```

**Правильно (сервис):**
```java
@Service
@Transactional(readOnly = true)
public class EntityService {
    private final EntityRepository repository;
    
    public Page<Entity> findAll(int page, int size, ...) {
        // ✅ ПРАВИЛЬНО: вся логика в сервисе
        Specification<Entity> spec = buildSpecification(...);
        Sort sort = buildSort(...);
        Pageable pageable = PageRequest.of(page, size, sort);
        return repository.findAll(spec, pageable);
    }
}
```

### Проверка:

При написании кода всегда спрашивать:
- Есть ли в контроллере бизнес-логика? → Перенести в сервис
- Работает ли контроллер напрямую с репозиторием? → Использовать сервис
- Есть ли в контроллере построение запросов к БД? → Перенести в сервис
- Содержит ли контроллер валидацию данных? → Перенести в сервис

**Цель:** Контроллеры должны быть максимально тонкими, содержать только HTTP-специфичную логику.

## Разделение методов парсинга Excel

**КРИТИЧЕСКИ ВАЖНО:** Для парсинга каждой сущности из Excel файла должен быть создан отдельный метод, даже если общий подход одинаковый.

### Правила:

1. **Каждая сущность = отдельный метод:**
   - Для парсинга `PurchaseRequest` - метод `loadPurchaseRequestsFromExcel()`
   - Для парсинга `Purchase` - метод `loadPurchasesFromExcel()`
   - Для парсинга `User` - метод `loadUsersFromExcel()`
   - Каждый метод отвечает только за одну сущность

2. **Общий подход, но отдельные методы:**
   - Все методы могут использовать общие вспомогательные методы (`parseLongCell`, `parseDateCell`, `getCellValueAsString`, `buildColumnIndexMap`, `findColumnIndex` и т.д.)
   - Каждый метод имеет свою логику фильтрации по "Вид документа" или другим критериям
   - Каждый метод имеет свой метод парсинга строки (`parsePurchaseRequestRow`, `parsePurchaseRow` и т.д.)

3. **Структура методов:**
   ```java
   // Метод загрузки для одной сущности
   public int loadEntityFromExcel(File excelFile) throws IOException {
       // 1. Открыть workbook
       // 2. Прочитать заголовки
       // 3. Найти нужные колонки
       // 4. Итерироваться по строкам
       // 5. Фильтровать по типу документа (если нужно)
       // 6. Парсить строку в сущность
       // 7. Сохранить/обновить в БД
       // 8. Вернуть количество загруженных записей
   }
   
   // Метод парсинга одной строки в сущность
   private Entity parseEntityRow(Row row, ...) {
       // Парсинг всех полей сущности
   }
   
   // Метод обновления существующей сущности
   private boolean updateEntityFields(Entity existing, Entity newData) {
       // Обновление только измененных полей
   }
   ```

4. **Вызов методов:**
   - В сервисе загрузки (`PurchaseRequestUploadService`) вызывать все методы парсинга последовательно
   - Каждый метод обрабатывает свой тип данных из одного Excel файла
   - Результаты всех методов объединяются в общий ответ

5. **Пример правильной структуры:**
   ```java
   // ✅ ПРАВИЛЬНО: отдельные методы для каждой сущности
   public int loadPurchaseRequestsFromExcel(File excelFile) { ... }
   public int loadPurchasesFromExcel(File excelFile) { ... }
   public int loadUsersFromExcel(File excelFile) { ... }
   
   // ❌ НЕПРАВИЛЬНО: один метод для всех сущностей
   public int loadAllFromExcel(File excelFile) { 
       // парсинг заявок, закупок и пользователей в одном методе
   }
   ```

6. **Преимущества разделения:**
   - Легче поддерживать и тестировать
   - Каждый метод имеет четкую ответственность
   - Можно вызывать методы независимо
   - Проще добавлять новые типы сущностей

**ВАЖНО:** Даже если логика парсинга очень похожа для разных сущностей, создавать отдельные методы. Общую логику выносить во вспомогательные методы.

## Добавление новых столбцов в таблицу

**КРИТИЧЕСКИ ВАЖНО:** При добавлении нового столбца в таблицу (например, в `PurchaseRequestsTable` или `PurchasesTable`) **ОБЯЗАТЕЛЬНО** нужно добавить фильтр для этого столбца.

### Правила:

1. **Каждый столбец должен иметь фильтр:**
   - Если столбец отображает данные из сущности - добавить фильтр
   - Фильтр должен быть доступен прямо в заголовке столбца
   - Фильтр должен работать на бэкенде (не на клиенте)

2. **Типы фильтров:**
   - **Текстовые поля** (innerId, name, title и т.д.) - текстовый фильтр (input type="text")
   - **Выпадающие списки** (cfo, costType, contractType и т.д.) - select фильтр с множественным выбором
   - **Булевы поля** (isPlanned, requiresPurchase) - select фильтр с опциями "Да", "Нет", "Все"

3. **Структура фильтра:**
   - Фильтр должен быть в компоненте `SortableHeader`
   - Фильтр должен обновлять состояние `filters` или `localFilters`
   - Фильтр должен передаваться на бэкенд через параметры запроса
   - Фильтр должен сбрасываться кнопкой "Сбросить фильтры"

4. **Пример добавления столбца с фильтром:**
   ```typescript
   // 1. Добавить столбец в заголовок таблицы
   <SortableHeader 
     field="newField" 
     label="Новое поле" 
     filterType="text" // или "select"
     width="w-32"
   />
   
   // 2. Добавить ячейку в тело таблицы
   <td className="px-2 py-2 whitespace-nowrap text-xs text-gray-900 border-r border-gray-200">
     {item.newField || '-'}
   </td>
   
   // 3. Обновить SortableHeader для поддержки фильтров (если еще не поддерживает)
   // 4. Убедиться, что фильтр передается на бэкенд в fetchData
   // 5. Убедиться, что бэкенд поддерживает фильтрацию по этому полю
   ```

5. **Проверка:**
   - При добавлении столбца всегда проверять:
     - Есть ли фильтр в заголовке столбца?
     - Работает ли фильтр на бэкенде?
     - Сбрасывается ли фильтр кнопкой "Сбросить фильтры"?
     - Обновляется ли пагинация при изменении фильтра?

**ВАЖНО:** Не добавлять столбцы без фильтров. Каждый столбец с данными должен иметь возможность фильтрации.

