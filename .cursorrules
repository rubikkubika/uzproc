# Правила для Cursor AI

**⚠️ ВАЖНОЕ ПРАВИЛО ДЛЯ ТЕРМИНАЛА:** Все терминальные команды должны выполняться через Git Bash, а не через PowerShell или CMD. См. раздел "Использование терминала" ниже.

## Использование терминала

**КРИТИЧЕСКИ ВАЖНО:** Для всех терминальных команд использовать Git Bash в первую очередь, а не PowerShell или CMD.

**ОБЯЗАТЕЛЬНОЕ ПРАВИЛО:** При выполнении любой терминальной команды всегда использовать Git Bash. Это правило применяется ко ВСЕМ командам, включая запуск сервисов, остановку процессов, проверку портов и любые другие операции.

### Правила:

1. **Все команды должны выполняться через Git Bash:**
   - Использовать синтаксис bash для всех команд
   - Использовать Unix-подобные команды (`pkill`, `kill`, `lsof`, `curl` и т.д.)
   - Использовать bash-синтаксис для условных операций (`||`, `&&`, `2>/dev/null`)
   - **ПЕРВОЕ ДЕЙСТВИЕ:** Всегда пытаться использовать Git Bash перед PowerShell/CMD

2. **Проверка наличия Git Bash:**
   - Перед выполнением команд проверить наличие Git Bash: `Test-Path "C:\Program Files\Git\bin\bash.exe"` (PowerShell)
   - Если Git Bash не найден, проверить альтернативные пути: `C:\Program Files (x86)\Git\bin\bash.exe`
   - Если Git Bash не установлен, сообщить пользователю о необходимости установки Git для Windows

3. **Правильный способ запуска Git Bash из PowerShell:**
   
   Когда терминал по умолчанию - PowerShell (Windows), использовать следующий синтаксис для вызова Git Bash:
   ```powershell
   # Вызов Git Bash с одной командой
   & "C:\Program Files\Git\bin\bash.exe" -c "команда"
   
   # Вызов Git Bash с несколькими командами
   & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
   
   # Примеры правильных команд для остановки процессов:
   & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'spring-boot:run' || true"
   & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:8080) 2>/dev/null || true"
   
   # Примеры правильных команд для запуска:
   & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
   & "C:\Program Files\Git\bin\bash.exe" -c "sleep 15 && curl http://localhost:8080/api/health"
   ```
   
   **Важно:** 
   - Использовать `&` для вызова команды в PowerShell
   - Путь к Git Bash может отличаться, стандартный путь: `C:\Program Files\Git\bin\bash.exe`
   - Для переменных в bash командах использовать обратные кавычки: `` `$var `` вместо `$var`
   - Для строк в bash командах использовать одинарные кавычки: `'строка'`

4. **Примеры правильных команд (если терминал уже Git Bash):**
   ```bash
   # Остановка процессов
   pkill -f "spring-boot:run" || true
   kill -9 $(lsof -ti:8080) 2>/dev/null || true
   
   # Проверка портов
   lsof -ti:8080
   
   # Запуск сервисов
   cd backend && mvn spring-boot:run
   ```

5. **НЕ использовать:**
   - PowerShell команды (`Get-Process`, `Get-NetTCPConnection`, `Stop-Process` и т.д.) - только если Git Bash недоступен
   - CMD команды (`taskkill`, `netstat` и т.д.)
   - Windows-специфичные команды напрямую

6. **Исключения:**
   - PowerShell скрипты для деплоя (`scripts/deploy-simple.ps1`) остаются без изменений, так как они специально созданы для PowerShell
   - Docker команды (`docker compose`) работают одинаково в bash и PowerShell
   - Если Git Bash недоступен или не установлен, можно использовать PowerShell команды как запасной вариант

**ВАЖНО:** 
- **ВСЕ** команды должны быть написаны для Git Bash в первую очередь
- **ВСЕГДА** при работе в PowerShell использовать правильный синтаксис вызова Git Bash: `& "C:\Program Files\Git\bin\bash.exe" -c "команда"`
- Если терминал уже Git Bash, использовать команды напрямую без обертки
- **НИКОГДА** не использовать PowerShell команды (`Get-Process`, `Stop-Process` и т.д.) без попытки использовать Git Bash сначала
- Если команды Git Bash не работают (например, `pkill` или `lsof` не найдены), только тогда использовать PowerShell как запасной вариант

**НАПОМИНАНИЕ:** Это правило применяется автоматически ко всем терминальным операциям. Не нужно спрашивать пользователя - просто использовать Git Bash по умолчанию.

## Деплой на сервер
Когда пользователь упоминает "деплой", "deploy", "опубликовать", "публикация", "выложить на сервер" или похожие фразы, необходимо автоматически выполнить скрипт деплоя:

1. Выполнить PowerShell скрипт `scripts/deploy-simple.ps1` из корня проекта
2. Скрипт автоматически:
   - Соберет Docker образы (frontend, backend)
   - Сохранит их в tar файлы
   - Скопирует образы и `docker-compose.yml` на сервер (devops@10.123.48.62)
   - Обновит контейнеры на сервере

**ВАЖНО:** При деплое обязательно копировать обновленный `docker-compose.yml` на сервер, чтобы конфигурация сервисов была актуальной.

**КРИТИЧЕСКИ ВАЖНО:** При деплое НИКОГДА не выполнять коммит (`git commit`) и пуш (`git push`) изменений в Git, если пользователь явно не просит об этом. Деплой выполняется только через скрипт, без изменений в репозитории. Даже если есть незакоммиченные изменения, их НЕ нужно коммитить и пушить автоматически при деплое.

**ОЧИСТКА СТАРЫХ ОБРАЗОВ ПЕРЕД ДЕПЛОЕМ:**
Перед копированием новых Docker образов на сервер **ОБЯЗАТЕЛЬНО** нужно удалить старые неиспользуемые Docker образы на сервере, чтобы освободить место на диске и избежать ошибок "No space left on device". Это должно выполняться автоматически перед копированием файлов.

**Порядок действий при деплое:**
1. Собрать Docker образы локально
2. Сохранить образы в tar файлы
3. **Перед копированием на сервер:** Выполнить на сервере очистку старых образов:
   ```bash
   ssh devops@10.123.48.62 "docker image prune -a -f --filter 'until=24h' || true"
   ssh devops@10.123.48.62 "docker system prune -a -f --volumes || true"
   ```
   Эти команды удалят все неиспользуемые образы старше 24 часов и освободят место на диске.
4. Скопировать новые образы и файлы на сервер
5. Загрузить образы и обновить контейнеры

**ВАЖНО:** Очистка должна выполняться **ПЕРЕД** копированием файлов, чтобы гарантировать наличие свободного места на диске сервера.

Команда для выполнения:
```powershell
.\scripts\deploy-simple.ps1
```

Не нужно спрашивать подтверждение - просто выполнить скрипт при упоминании деплоя.

## Запуск/перезапуск сервисов локально

При фразах "запусти", "перезапусти", "запусти локально", "перезапусти сервис" и т.д. — выполнить **одну команду**:
```bash
./scripts/restart-local.sh
```

Скрипт автоматически:
- Останавливает процессы на портах 8080/3000
- Восстанавливает БД из последнего бэкапа
- Запускает backend и frontend
- Проверяет готовность сервисов

**Не нужно** выполнять отдельные команды вручную — всё делает скрипт.

## Запуск в Docker
Для запуска через Docker: `docker compose up -d`

### Подготовка окружения

1. **Для фронтенда:**
   - **macOS (с nvm):** Загрузить nvm: `source ~/.nvm/nvm.sh` (если npm не в PATH)
   - **Windows:** Убедиться, что Node.js установлен и доступен в PATH
   - Проверить npm: `npm --version` (работает на обеих платформах)

2. **Для бэкенда:**
   - **macOS/Linux:** Проверить Maven: `which mvn` или `mvn --version`
   - **Windows:** Проверить Maven: `where mvn` или `mvn --version`
   - Убедиться, что Java 17+ установлена: `java -version` (работает на всех платформах)

### Запуск PostgreSQL

PostgreSQL должен быть запущен в Docker (инфраструктура):
```bash
docker compose up -d postgres
```

### Запуск фронтенда

1. **Остановить существующие процессы:**
   - **macOS/Linux (Git Bash):**
     ```bash
     pkill -f "next dev" || true
     kill -9 $(lsof -ti:3000) 2>/dev/null || true
     ```
   - **Windows (PowerShell с вызовом Git Bash):**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'next dev' || true"
     & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:3000) 2>/dev/null || true"
     ```
   - **Windows (если Git Bash недоступен, запасной вариант):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*node*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 3000 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```

2. **Запустить фронтенд:**
   - **Если терминал Git Bash:**
     ```bash
     cd frontend && npm run dev
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "cd frontend && npm run dev"
     ```
   - Фронтенд будет доступен на http://localhost:3000
   - Скрипты в `package.json` используют стандартные команды (`next dev`), которые работают на Mac и Windows

### Запуск бэкенда

1. **Остановить существующие процессы:**
   - **macOS/Linux (Git Bash):**
     ```bash
     pkill -f "spring-boot:run" || true
     kill -9 $(lsof -ti:8080) 2>/dev/null || true
     ```
   - **Windows (PowerShell с вызовом Git Bash):**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "pkill -f 'spring-boot:run' || true"
     & "C:\Program Files\Git\bin\bash.exe" -c "kill -9 `$(lsof -ti:8080) 2>/dev/null || true"
     ```
   - **Windows (если Git Bash недоступен, запасной вариант):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*java*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 8080 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```

2. **Запустить бэкенд:**
   - **Если терминал Git Bash:**
     ```bash
     cd backend && mvn spring-boot:run
     ```
   - **Если терминал PowerShell:**
     ```powershell
     & "C:\Program Files\Git\bin\bash.exe" -c "cd backend && mvn spring-boot:run"
     ```
   - Бэкенд будет доступен на http://localhost:8080/api
   - Health check: http://localhost:8080/api/health
   - Команда `mvn spring-boot:run` работает одинаково на всех платформах

### Проверка статуса

После запуска проверить:
- **Фронтенд:**
  - macOS/Linux (Git Bash): `curl http://localhost:3000` (ожидается HTTP 307 или 200)
  - Windows (PowerShell с Git Bash): `& "C:\Program Files\Git\bin\bash.exe" -c "curl http://localhost:3000"`
  - Windows (запасной вариант): `Invoke-WebRequest http://localhost:3000` (PowerShell)
- **Бэкенд:**
  - macOS/Linux (Git Bash): `curl http://localhost:8080/api/health` (ожидается `{"service":"uzproc-backend","status":"UP"}`)
  - Windows (PowerShell с Git Bash): `& "C:\Program Files\Git\bin\bash.exe" -c "curl http://localhost:8080/api/health"`
  - Windows (запасной вариант): `Invoke-WebRequest http://localhost:8080/api/health` (PowerShell)

### Важные замечания

- **npm должен быть в PATH:**
  - macOS: настроено через `.bash_profile` и `.zshrc` для автоматической загрузки nvm
  - Windows: Node.js должен быть установлен и добавлен в PATH системы (обычно делается автоматически при установке)
- PostgreSQL запускается в Docker, так как это инфраструктура (команда `docker compose up -d postgres` работает одинаково на всех платформах)
- При перезапуске всегда останавливать старые процессы перед запуском новых (использовать Git Bash команды в первую очередь)
- Запускать сервисы в фоновом режиме (`is_background: true`) или с перенаправлением вывода для логирования
- **На Windows использовать Git Bash через PowerShell:** `& "C:\Program Files\Git\bin\bash.exe" -c "команда"`

## Создание скриптов
НЕ создавать скрипты (shell, PowerShell, bash и т.д.) автоматически, если пользователь явно не запросил создание скрипта. Создавать скрипты только когда пользователь явно просит:
- "создай скрипт"
- "напиши скрипт"
- "сделай скрипт"
- "автоматизируй через скрипт"
- или похожие явные запросы

Если задача может быть решена без скрипта (например, через прямые команды или изменения в коде), не предлагать и не создавать скрипты.

## Документация
Всю документацию (README.md, инструкции, руководства, API документацию и т.д.) необходимо хранить в папке `docs` в корне проекта. 

- README файлы для отдельных модулей (например, `backend/README.md`, `frontend/README.md`) можно оставлять в соответствующих папках
- Общую документацию проекта, инструкции по развертыванию, архитектурные решения и другую проектную документацию размещать в `docs/`
- При создании новой документации предлагать размещение в `docs/`, если это не специфичный README для модуля

## Добавление новых полей и парсинг Excel

При добавлении новых полей в сущность `PurchaseRequest` и их парсинга из Excel файлов, **ОБЯЗАТЕЛЬНО** нужно:

1. **Изучить существующие поля и их парсинг:**
   - Посмотреть, как парсятся другие опциональные поля (например, `cfo`, `name`, `title`, `innerId`) в методе `parsePurchaseRequestRow` класса `ExcelLoadService`
   - Использовать аналогичную логику и структуру кода
   - Следовать тем же паттернам и стилю кода

2. **Добавить константу для названия колонки:**
   - Добавить `private static final String NEW_FIELD_COLUMN = "Название колонки в Excel";` в начало класса `ExcelLoadService`
   - Использовать точное название колонки из Excel файла

3. **Найти колонку в заголовке:**
   - Использовать `findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN)` для поиска колонки
   - Если колонка может иметь альтернативные названия, добавить проверки с `findColumnIndex` для каждого варианта
   - Добавить логирование, если колонка не найдена (как для других полей)

4. **Парсинг значения:**
   - Для строковых полей: использовать `getCellValueAsString(cell)` и проверку на `null` и пустоту
   - Для булевых полей: использовать `parseBooleanCell(cell)` и проверку на `null`
   - Для числовых полей: использовать соответствующие методы парсинга (`parseLongCell`, `parseDateCell` и т.д.)
   - Следовать той же структуре проверок, что и для других полей

5. **Обновление существующих записей:**
   - Добавить логику обновления нового поля в метод `updatePurchaseRequestFields`
   - Использовать тот же паттерн проверки на изменения, что и для других полей
   - Добавить логирование обновлений

6. **Пример структуры для опционального строкового поля:**
   ```java
   // В методе loadPurchaseRequestsFromExcel:
   Integer newFieldColumnIndex = findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN);
   
   // В методе parsePurchaseRequestRow:
   if (newFieldColumnIndex != null) {
       Cell newFieldCell = row.getCell(newFieldColumnIndex);
       String newField = getCellValueAsString(newFieldCell);
       if (newField != null && !newField.trim().isEmpty()) {
           pr.setNewField(newField.trim());
       }
   }
   
   // В методе updatePurchaseRequestFields:
   if (newData.getNewField() != null && !newData.getNewField().trim().isEmpty()) {
       if (existing.getNewField() == null || !existing.getNewField().equals(newData.getNewField())) {
           existing.setNewField(newData.getNewField());
           updated = true;
           logger.debug("Updated newField for request {}: {}", existing.getIdPurchaseRequest(), newData.getNewField());
       }
   }
   ```

7. **Для булевых полей с обратной логикой:**
   - Если колонка называется "Не требуется..." или имеет обратную логику, проверить название колонки
   - Передать название колонки в метод `parsePurchaseRequestRow` как дополнительный параметр
   - Инвертировать логику парсинга, если необходимо

**ВАЖНО:** Всегда смотреть на существующие поля и делать аналогично. Не изобретать новые подходы, если уже есть рабочие примеры в коде.

## Автоматический перезапуск после изменений в бэкенде

После изменений в `backend/src/main/java/` или `application.yml` — выполнить:
```bash
./scripts/restart-local.sh
```

Не спрашивать подтверждение — перезапускать автоматически.

## Фильтрация данных на бэкенде

**КРИТИЧЕСКИ ВАЖНО:** Если данные получаются с бэкенда в отфильтрованном виде, то **ВСЯ фильтрация должна выполняться на бэкенде**, а не на клиенте.

### Правила:

1. **Все фильтры должны применяться на бэкенде:**
   - Фильтры по полям сущности (год, ЦФО, инициатор, название и т.д.) должны передаваться как параметры запроса на бэкенд
   - Бэкенд должен применять все фильтры через JPA Specification или аналогичный механизм
   - Пагинация должна применяться на бэкенде **ПОСЛЕ** применения всех фильтров

2. **Клиентская фильтрация допустима ТОЛЬКО если:**
   - Фильтрация основана на данных, которых нет в сущности на бэкенде (например, вычисляемые поля, агрегированные данные)
   - И это явно указано в комментариях с объяснением причины
   - В этом случае клиентская фильтрация должна применяться **ПЕРЕД** пагинацией, и пагинация должна применяться к уже отфильтрованным данным

3. **Пагинация:**
   - Пагинация всегда должна учитывать все примененные фильтры
   - Если фильтры применяются на бэкенде - пагинация тоже на бэкенде
   - Если фильтры применяются на клиенте - пагинация применяется к отфильтрованным данным на клиенте
   - `totalElements` и `totalPages` должны отражать количество записей **после** применения всех фильтров

4. **Множественный выбор:**
   - Для множественного выбора (например, несколько ЦФО) использовать массив параметров или список значений
   - На бэкенде использовать `IN` запрос или `OR` условия для множественного выбора

5. **Проверка:**
   - При реализации фильтрации всегда проверять, что пагинация учитывает все фильтры
   - Убедиться, что `totalElements` соответствует количеству отфильтрованных записей, а не всех записей в базе

**Пример правильной реализации:**
- Фронтенд передает все параметры фильтрации на бэкенд
- Бэкенд применяет все фильтры через Specification
- Бэкенд применяет пагинацию к отфильтрованным данным
- Бэкенд возвращает `Page` с правильными `totalElements` и `totalPages`
- Фронтенд использует данные напрямую без дополнительной фильтрации

## Разделение ответственности: Контроллеры и Сервисы

**КРИТИЧЕСКИ ВАЖНО:** При создании нового контроллера **ОБЯЗАТЕЛЬНО** нужно создать соответствующий сервисный слой. Вся бизнес-логика должна находиться в сервисах, контроллеры должны только обрабатывать HTTP-запросы.

### Правило при создании новых контроллеров:

1. **Всегда создавать сервис перед контроллером:**
   - При создании нового контроллера сначала создать соответствующий сервис
   - Контроллер должен только вызывать методы сервиса
   - Вся логика работы с данными, валидация, бизнес-правила - в сервисе

2. **Структура создания:**
   ```
   1. Создать Entity (если еще нет)
   2. Создать Repository (если еще нет)
   3. Создать Service с бизнес-логикой
   4. Создать Controller, который использует Service
   ```

3. **Пример правильного подхода:**
   ```java
   // ✅ ПРАВИЛЬНО: Сначала сервис
   @Service
   @Transactional(readOnly = true)
   public class NewEntityService {
       private final NewEntityRepository repository;
       
       public List<NewEntity> findAll() {
           // Вся логика здесь
           return repository.findAll();
       }
   }
   
   // Затем контроллер
   @RestController
   @RequestMapping("/api/new-entities")
   public class NewEntityController {
       private final NewEntityService service;
       
       @GetMapping
       public ResponseEntity<List<NewEntity>> getAll() {
           return ResponseEntity.ok(service.findAll());
       }
   }
   ```

4. **Что НЕ делать:**
   ```java
   // ❌ НЕПРАВИЛЬНО: Логика в контроллере
   @RestController
   @RequestMapping("/api/new-entities")
   public class NewEntityController {
       private final NewEntityRepository repository; // ❌ Прямая работа с репозиторием
       
       @GetMapping
       public ResponseEntity<List<NewEntity>> getAll() {
           // ❌ Логика в контроллере
           return ResponseEntity.ok(repository.findAll());
       }
   }
   ```

### Правила для контроллеров:

1. **Контроллеры должны быть тонкими:**
   - Принимать HTTP-запросы и параметры
   - Вызывать методы сервисов
   - Возвращать HTTP-ответы (ResponseEntity)
   - Обрабатывать HTTP-специфичные вещи (коды статусов, заголовки)

2. **Контроллеры НЕ должны содержать:**
   - Бизнес-логику
   - Построение запросов к базе данных (Specification, Query)
   - Валидацию данных (кроме базовой проверки на null)
   - Обработку файлов (кроме получения MultipartFile)
   - Сложные вычисления или преобразования данных
   - Прямую работу с репозиториями (только через сервисы)

3. **Что допустимо в контроллерах:**
   - Маппинг параметров запроса в параметры методов сервисов
   - Определение HTTP-кодов ответов на основе результатов сервисов
   - Простая проверка на null перед вызовом сервиса
   - Логирование HTTP-запросов (но не бизнес-логики)

### Правила для сервисов:

1. **Сервисы содержат всю бизнес-логику:**
   - Построение запросов к базе данных (Specification, Query)
   - Фильтрация, сортировка, пагинация
   - Валидация данных
   - Обработка файлов
   - Преобразование данных
   - Работа с репозиториями
   - Сложные вычисления

2. **Сервисы должны быть:**
   - Помечены аннотацией `@Service`
   - Использовать `@Transactional` для операций с базой данных
   - Содержать логирование бизнес-логики
   - Быть независимыми от HTTP-слоя

3. **Структура сервиса:**
   ```java
   @Service
   @Transactional(readOnly = true) // для read-only операций
   public class EntityService {
       private final EntityRepository repository;
       
       public Page<Entity> findAll(...) {
           // Вся логика фильтрации, сортировки, пагинации
       }
       
       public Entity findById(Long id) {
           // Логика поиска
       }
   }
   ```

### Примеры правильной реализации:

**Правильно (контроллер):**
```java
@RestController
@RequestMapping("/entities")
public class EntityController {
    private final EntityService entityService;
    
    @GetMapping
    public ResponseEntity<Page<Entity>> getAll(
            @RequestParam int page,
            @RequestParam int size) {
        Page<Entity> entities = entityService.findAll(page, size);
        return ResponseEntity.ok(entities);
    }
}
```

**Неправильно (логика в контроллере):**
```java
@RestController
@RequestMapping("/entities")
public class EntityController {
    private final EntityRepository repository;
    
    @GetMapping
    public ResponseEntity<Page<Entity>> getAll(...) {
        // ❌ НЕПРАВИЛЬНО: построение Specification в контроллере
        Specification<Entity> spec = (root, query, cb) -> { ... };
        Page<Entity> entities = repository.findAll(spec, pageable);
        return ResponseEntity.ok(entities);
    }
}
```

**Правильно (сервис):**
```java
@Service
@Transactional(readOnly = true)
public class EntityService {
    private final EntityRepository repository;
    
    public Page<Entity> findAll(int page, int size, ...) {
        // ✅ ПРАВИЛЬНО: вся логика в сервисе
        Specification<Entity> spec = buildSpecification(...);
        Sort sort = buildSort(...);
        Pageable pageable = PageRequest.of(page, size, sort);
        return repository.findAll(spec, pageable);
    }
}
```

### Проверка:

При написании кода всегда спрашивать:
- Есть ли в контроллере бизнес-логика? → Перенести в сервис
- Работает ли контроллер напрямую с репозиторием? → Использовать сервис
- Есть ли в контроллере построение запросов к БД? → Перенести в сервис
- Содержит ли контроллер валидацию данных? → Перенести в сервис

**Цель:** Контроллеры должны быть максимально тонкими, содержать только HTTP-специфичную логику.

## Разделение методов парсинга Excel

**КРИТИЧЕСКИ ВАЖНО:** Для парсинга каждой сущности из Excel файла должен быть создан отдельный метод, даже если общий подход одинаковый.

### Правила:

1. **Каждая сущность = отдельный метод:**
   - Для парсинга `PurchaseRequest` - метод `loadPurchaseRequestsFromExcel()`
   - Для парсинга `Purchase` - метод `loadPurchasesFromExcel()`
   - Для парсинга `User` - метод `loadUsersFromExcel()`
   - Каждый метод отвечает только за одну сущность

2. **Общий подход, но отдельные методы:**
   - Все методы могут использовать общие вспомогательные методы (`parseLongCell`, `parseDateCell`, `getCellValueAsString`, `buildColumnIndexMap`, `findColumnIndex` и т.д.)
   - Каждый метод имеет свою логику фильтрации по "Вид документа" или другим критериям
   - Каждый метод имеет свой метод парсинга строки (`parsePurchaseRequestRow`, `parsePurchaseRow` и т.д.)

3. **Структура методов:**
   ```java
   // Метод загрузки для одной сущности
   public int loadEntityFromExcel(File excelFile) throws IOException {
       // 1. Открыть workbook
       // 2. Прочитать заголовки
       // 3. Найти нужные колонки
       // 4. Итерироваться по строкам
       // 5. Фильтровать по типу документа (если нужно)
       // 6. Парсить строку в сущность
       // 7. Сохранить/обновить в БД
       // 8. Вернуть количество загруженных записей
   }
   
   // Метод парсинга одной строки в сущность
   private Entity parseEntityRow(Row row, ...) {
       // Парсинг всех полей сущности
   }
   
   // Метод обновления существующей сущности
   private boolean updateEntityFields(Entity existing, Entity newData) {
       // Обновление только измененных полей
   }
   ```

4. **Вызов методов:**
   - В сервисе загрузки (`PurchaseRequestUploadService`) вызывать все методы парсинга последовательно
   - Каждый метод обрабатывает свой тип данных из одного Excel файла
   - Результаты всех методов объединяются в общий ответ

5. **Пример правильной структуры:**
   ```java
   // ✅ ПРАВИЛЬНО: отдельные методы для каждой сущности
   public int loadPurchaseRequestsFromExcel(File excelFile) { ... }
   public int loadPurchasesFromExcel(File excelFile) { ... }
   public int loadUsersFromExcel(File excelFile) { ... }
   
   // ❌ НЕПРАВИЛЬНО: один метод для всех сущностей
   public int loadAllFromExcel(File excelFile) { 
       // парсинг заявок, закупок и пользователей в одном методе
   }
   ```

6. **Преимущества разделения:**
   - Легче поддерживать и тестировать
   - Каждый метод имеет четкую ответственность
   - Можно вызывать методы независимо
   - Проще добавлять новые типы сущностей

**ВАЖНО:** Даже если логика парсинга очень похожа для разных сущностей, создавать отдельные методы. Общую логику выносить во вспомогательные методы.

## Добавление новых столбцов в таблицу

**КРИТИЧЕСКИ ВАЖНО:** При добавлении нового столбца в таблицу (например, в `PurchaseRequestsTable` или `PurchasesTable`) **ОБЯЗАТЕЛЬНО** нужно добавить фильтр для этого столбца.

### Правила:

1. **Каждый столбец должен иметь фильтр:**
   - Если столбец отображает данные из сущности - добавить фильтр
   - Фильтр должен быть доступен прямо в заголовке столбца
   - Фильтр должен работать на бэкенде (не на клиенте)

2. **Типы фильтров:**
   - **Текстовые поля** (innerId, name, title и т.д.) - текстовый фильтр (input type="text")
   - **Выпадающие списки** (cfo, costType, contractType и т.д.) - select фильтр с множественным выбором
   - **Булевы поля** (isPlanned, requiresPurchase) - select фильтр с опциями "Да", "Нет", "Все"

3. **Структура фильтра:**
   - Фильтр должен быть в компоненте `SortableHeader`
   - Фильтр должен обновлять состояние `filters` или `localFilters`
   - Фильтр должен передаваться на бэкенд через параметры запроса
   - Фильтр должен сбрасываться кнопкой "Сбросить фильтры"

4. **Пример добавления столбца с фильтром:**
   ```typescript
   // 1. Добавить столбец в заголовок таблицы
   <SortableHeader 
     field="newField" 
     label="Новое поле" 
     filterType="text" // или "select"
     width="w-32"
   />
   
   // 2. Добавить ячейку в тело таблицы
   <td className="px-2 py-2 whitespace-nowrap text-xs text-gray-900 border-r border-gray-200">
     {item.newField || '-'}
   </td>
   
   // 3. Обновить SortableHeader для поддержки фильтров (если еще не поддерживает)
   // 4. Убедиться, что фильтр передается на бэкенд в fetchData
   // 5. Убедиться, что бэкенд поддерживает фильтрацию по этому полю
   ```

5. **Проверка:**
   - При добавлении столбца всегда проверять:
     - Есть ли фильтр в заголовке столбца?
     - Работает ли фильтр на бэкенде?
     - Сбрасывается ли фильтр кнопкой "Сбросить фильтры"?
     - Обновляется ли пагинация при изменении фильтра?

**ВАЖНО:** Не добавлять столбцы без фильтров. Каждый столбец с данными должен иметь возможность фильтрации.

## Стандартизация таблиц

**КРИТИЧЕСКИ ВАЖНО:** При создании новой таблицы или обновлении существующей таблицы на фронтенде **ОБЯЗАТЕЛЬНО** нужно использовать те же стили, структуру и функциональность, что и в таблице "Заявка на закупку" (`PurchaseRequestsTable.tsx`), если не задано другое.

### Правила:

1. **Структура таблицы:**
   - Использовать `w-full border-collapse` для элемента `<table>`
   - Использовать `bg-gray-50` для `<thead>`
   - Использовать `bg-white divide-y divide-gray-200` для `<tbody>`
   - Использовать `overflow-x-auto relative` для контейнера таблицы

2. **Заголовки таблицы (`<th>`):**
   - Отступы: `px-2 py-2`
   - Классы: `text-left text-xs font-medium text-gray-500 tracking-wider border-r border-gray-300 relative`
   - Структура заголовка: `flex flex-col gap-1` с двумя уровнями:
     - Верхний уровень (24px высота): фильтры (`h-[24px] flex items-center flex-shrink-0`)
     - Нижний уровень (20px высота): сортировка и название (`flex items-center gap-1 min-h-[20px]`)

3. **Фильтры:**
   - Текстовые фильтры: `flex-1 text-xs border border-gray-300 rounded px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-blue-500`
   - Высота фильтров: `height: '24px', minHeight: '24px', maxHeight: '24px', minWidth: 0, boxSizing: 'border-box'`
   - Множественные фильтры (чекбоксы): использовать выпадающие списки с поиском, как в фильтре ЦФО

4. **Сортировка:**
   - Кнопка сортировки: `flex items-center justify-center hover:text-gray-700 transition-colors flex-shrink-0`
   - Размер кнопки: `width: '20px', height: '20px', minWidth: '20px', maxWidth: '20px', minHeight: '20px', maxHeight: '20px', padding: 0`
   - Иконки: `ArrowUp`, `ArrowDown`, `ArrowUpDown` из `lucide-react`
   - Название колонки: `text-xs font-medium text-gray-500 tracking-wider` (для ЦФО добавить `uppercase`)

5. **Ячейки таблицы (`<td>`):**
   - Отступы: `px-2 py-2`
   - Классы: `text-xs text-gray-900 border-r border-gray-300`
   - Для ячеек с текстом, который не должен переноситься: добавить `whitespace-nowrap`

6. **Пагинация:**
   - Контейнер: `px-6 py-4 border-b border-gray-200 flex items-center justify-between bg-gray-50`
   - Кнопки пагинации: `px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed`
   - Селект размера страницы: `px-3 py-1.5 text-sm border border-gray-300 rounded-lg bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500`

7. **Общий контейнер таблицы:**
   - Внешний контейнер: `bg-white rounded-lg shadow-lg overflow-hidden`
   - Пагинация размещается в отдельном блоке с `border-b border-gray-200`

8. **Расширение столбцов:**
   - Если требуется расширение столбцов, использовать тот же механизм, что и в `PurchaseRequestsTable` (drag-and-drop для изменения порядка, resize для изменения ширины)

9. **Перенос строк:**
   - По умолчанию использовать `whitespace-nowrap` для ячеек, чтобы текст не переносился
   - Если требуется перенос, убрать `whitespace-nowrap` и добавить соответствующие стили

### Пример правильной структуры заголовка:

```typescript
<th className="px-2 py-2 text-left text-xs font-medium text-gray-500 tracking-wider border-r border-gray-300 relative">
  <div className="flex flex-col gap-1" style={{ minWidth: 0, width: '100%' }}>
    {/* Верхний уровень - фильтр */}
    <div className="h-[24px] flex items-center gap-1 flex-shrink-0" style={{ minHeight: '24px', maxHeight: '24px', minWidth: 0, width: '100%' }}>
      <input
        type="text"
        className="flex-1 text-xs border border-gray-300 rounded px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-blue-500"
        placeholder="Фильтр"
        style={{ height: '24px', minHeight: '24px', maxHeight: '24px', minWidth: 0, boxSizing: 'border-box' }}
      />
    </div>
    {/* Нижний уровень - сортировка и название */}
    <div className="flex items-center gap-1 min-h-[20px]">
      <button
        onClick={() => handleSort('field')}
        className="flex items-center justify-center hover:text-gray-700 transition-colors flex-shrink-0"
        style={{ width: '20px', height: '20px', minWidth: '20px', maxWidth: '20px', minHeight: '20px', maxHeight: '20px', padding: 0 }}
      >
        {/* Иконка сортировки */}
      </button>
      <span className="text-xs font-medium text-gray-500 tracking-wider">Название колонки</span>
    </div>
  </div>
</th>
```

### Проверка:

При создании или обновлении таблицы всегда проверять:
- Соответствуют ли стили заголовков таблице "Заявка на закупку"?
- Правильно ли структурированы фильтры и сортировка?
- Соответствует ли пагинация стандарту?
- Правильно ли оформлены ячейки таблицы?
- Используются ли правильные цвета и отступы?

**ВАЖНО:** Если пользователь явно просит использовать другие стили или структуру, следовать указаниям пользователя. В остальных случаях использовать стандарт таблицы "Заявка на закупку".

## Реализация полей ввода для фильтров

**КРИТИЧЕСКИ ВАЖНО:** При создании полей ввода для фильтров в таблицах **ОБЯЗАТЕЛЬНО** нужно использовать следующие настройки для сохранения фокуса и корректной работы debounce.

### Обязательные настройки для текстовых полей фильтров:

1. **Состояние для отслеживания фокуса:**
   ```typescript
   const [focusedField, setFocusedField] = useState<string | null>(null);
   ```

2. **Структура поля ввода:**
   ```typescript
   <input
     key={`filter-${field || ''}`}
     type="text"
     data-filter-field={field || ''}
     value={localFilters[field || ''] || ''}
     onChange={(e) => {
       const newValue = e.target.value;
       const cursorPos = e.target.selectionStart || 0;
       setLocalFilters(prev => ({
         ...prev,
         [field || '']: newValue,
       }));
       // Сохраняем позицию курсора после обновления
       requestAnimationFrame(() => {
         const input = e.target as HTMLInputElement;
         if (input && document.activeElement === input) {
           const newPos = Math.min(cursorPos, newValue.length);
           input.setSelectionRange(newPos, newPos);
         }
       });
     }}
     onFocus={(e) => {
       e.stopPropagation();
       setFocusedField(field || '');
     }}
     onBlur={(e) => {
       // Снимаем фокус только если пользователь явно кликнул в другое место
       setTimeout(() => {
         const activeElement = document.activeElement as HTMLElement;
         if (activeElement && 
             activeElement !== e.target && 
             !activeElement.closest('input[data-filter-field]') &&
             !activeElement.closest('select')) {
           setFocusedField(null);
         }
       }, 200);
     }}
     onClick={(e) => e.stopPropagation()}
     onKeyDown={(e) => {
       // Предотвращаем потерю фокуса при нажатии некоторых клавиш
       if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
         e.stopPropagation();
       }
     }}
     className="flex-1 text-xs border border-gray-300 rounded px-1 py-0.5 bg-white focus:outline-none focus:ring-1 focus:ring-blue-500"
     placeholder="Фильтр"
     style={{ height: '24px', minHeight: '24px', maxHeight: '24px', minWidth: 0, boxSizing: 'border-box' }}
   />
   ```

3. **Debounce с восстановлением фокуса:**
   ```typescript
   // Debounce для текстовых фильтров
   useEffect(() => {
     const textFields = ['field1', 'field2', 'field3']; // список всех текстовых полей
     const hasTextChanges = textFields.some(field => localFilters[field] !== filters[field]);
     
     if (hasTextChanges) {
       // Сохраняем фокус перед обновлением
       const input = focusedField ? document.querySelector(`input[data-filter-field="${focusedField}"]`) as HTMLInputElement : null;
       const cursorPosition = input ? (input.selectionStart || 0) : null;
       
       const timer = setTimeout(() => {
         setFilters(prev => {
           const updated = { ...prev };
           textFields.forEach(field => {
             updated[field] = localFilters[field];
           });
           return updated;
         });
         setCurrentPage(0);
         
         // Восстанавливаем фокус после обновления
         if (focusedField && cursorPosition !== null) {
           setTimeout(() => {
             const inputAfterRender = document.querySelector(`input[data-filter-field="${focusedField}"]`) as HTMLInputElement;
             if (inputAfterRender) {
               inputAfterRender.focus();
               const newPos = Math.min(cursorPosition, inputAfterRender.value.length);
               inputAfterRender.setSelectionRange(newPos, newPos);
             }
           }, 0);
         }
       }, 500); // Задержка 500мс

       return () => clearTimeout(timer);
     }
   }, [localFilters, filters, focusedField]);
   ```

4. **Восстановление фокуса после обновления localFilters:**
   ```typescript
   // Восстановление фокуса после обновления localFilters
   useEffect(() => {
     if (focusedField) {
       const input = document.querySelector(`input[data-filter-field="${focusedField}"]`) as HTMLInputElement;
       if (input) {
         const cursorPosition = input.selectionStart || 0;
         const currentValue = input.value;
         
         requestAnimationFrame(() => {
           const inputAfterRender = document.querySelector(`input[data-filter-field="${focusedField}"]`) as HTMLInputElement;
           if (inputAfterRender && inputAfterRender.value === currentValue) {
             inputAfterRender.focus();
             const newPosition = Math.min(cursorPosition, inputAfterRender.value.length);
             inputAfterRender.setSelectionRange(newPosition, newPosition);
           }
         });
       }
     }
   }, [localFilters, focusedField]);
   ```

5. **Восстановление фокуса после обновления данных:**
   ```typescript
   // Восстановление фокуса после обновления данных
   useEffect(() => {
     if (focusedField && !loading) {
       setTimeout(() => {
         const input = document.querySelector(`input[data-filter-field="${focusedField}"]`) as HTMLInputElement;
         if (input) {
           input.focus();
           const length = input.value.length;
           input.setSelectionRange(length, length);
         }
       }, 50);
     }
   }, [data, loading, focusedField]);
   ```

### Ключевые особенности реализации:

1. **`key` атрибут:** Используется для стабильной идентификации поля при перерисовке компонента
2. **`data-filter-field` атрибут:** Используется для поиска поля в DOM при восстановлении фокуса
3. **Сохранение позиции курсора:** В `onChange` сохраняется позиция курсора и восстанавливается через `requestAnimationFrame`
4. **Отслеживание фокуса:** `focusedField` отслеживает активное поле, чтобы восстановить фокус после обновлений
5. **`onBlur` с задержкой:** Используется `setTimeout` для проверки, действительно ли фокус потерян (возможно, пользователь кликнул на другой фильтр)
6. **`stopPropagation`:** Предотвращает всплытие событий, которые могут вызвать нежелательное поведение
7. **Debounce с восстановлением:** При применении debounce фокус и позиция курсора сохраняются и восстанавливаются

### Преимущества этого подхода:

- ✅ Фокус не теряется при вводе текста
- ✅ Позиция курсора сохраняется при вводе
- ✅ Фокус восстанавливается после обновления данных с сервера
- ✅ Работает корректно с debounce (задержка перед отправкой запроса)
- ✅ Пользователь может беспрепятственно вводить текст без потери фокуса

### Для select-полей:

Для select-полей используется другая логика - обновление обоих состояний сразу без debounce:
```typescript
<select
  value={filters[field || ''] || ''}
  onChange={(e) => handleFilterChange(field || '', e.target.value, false)}
  onClick={(e) => e.stopPropagation()}
  onFocus={(e) => e.stopPropagation()}
  className="flex-1 text-xs border border-gray-300 rounded px-1 py-0.5 bg-white focus:outline-none focus:ring-1 focus:ring-blue-500"
  style={{ height: '24px', minHeight: '24px', maxHeight: '24px', minWidth: 0, boxSizing: 'border-box' }}
>
  {/* опции */}
</select>
```

**ВАЖНО:** Все эти настройки обязательны для корректной работы полей ввода фильтров. Без них пользователь будет терять фокус при вводе текста, что создает плохой пользовательский опыт.

## Цвет текста в полях ввода

**КРИТИЧЕСКИ ВАЖНО:** При добавлении новых полей ввода (input, textarea) **ОБЯЗАТЕЛЬНО** нужно использовать темный цвет текста для обеспечения читаемости.

### Обязательные классы для полей ввода:

1. **Для всех текстовых полей ввода:**
   ```typescript
   <input
     type="text"
     className="... text-gray-900 bg-white ..."
     // или
     className="... text-black bg-white ..."
   />
   ```

2. **Для полей email:**
   ```typescript
   <input
     type="email"
     className="... text-gray-900 bg-white ..."
   />
   ```

3. **Для полей password:**
   ```typescript
   <input
     type="password"
     className="... text-gray-900 bg-white ..."
   />
   ```

4. **Для textarea:**
   ```typescript
   <textarea
     className="... text-gray-900 bg-white ..."
   />
   ```

### Рекомендуемые классы:

- **Темный цвет текста:** `text-gray-900` (предпочтительно) или `text-black`
- **Белый фон:** `bg-white` (для контраста и читаемости)
- **Для placeholder:** можно использовать `placeholder:text-gray-400` или `placeholder:text-gray-500`

### Пример правильной реализации:

```typescript
// ✅ ПРАВИЛЬНО: темный текст и белый фон
<input
  type="text"
  value={value}
  onChange={(e) => setValue(e.target.value)}
  className="w-full px-3 py-2 text-sm text-gray-900 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
  placeholder="Введите значение"
/>

// ✅ ПРАВИЛЬНО: для модальных окон и форм
<input
  type="email"
  value={email}
  onChange={(e) => setEmail(e.target.value)}
  className="w-full px-3 py-2 text-sm text-gray-900 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
  placeholder="Введите email"
/>

// ❌ НЕПРАВИЛЬНО: без указания цвета текста (может быть светлым и нечитаемым)
<input
  type="text"
  className="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg"
  // Отсутствует text-gray-900 или text-black
/>
```

### Исключения:

- Поля ввода в фильтрах таблиц могут использовать стандартные стили из раздела "Реализация полей ввода для фильтров", но также должны иметь темный цвет текста
- Если поле ввода имеет специальный дизайн (например, поиск с иконкой), темный цвет текста все равно обязателен

**ВАЖНО:** Всегда проверять, что текст в полях ввода хорошо читается. Темный цвет текста (`text-gray-900` или `text-black`) в сочетании с белым фоном (`bg-white`) обеспечивает оптимальную читаемость и соответствует стандартам доступности.


## Git коммиты и пуш

**КРИТИЧЕСКИ ВАЖНО:** При выполнении команд коммита и пуша (`git commit`, `git push`) **ОБЯЗАТЕЛЬНО** нужно использовать краткое и понятное описание коммита.

### Правила для коммитов:

1. **Формат сообщения коммита:**
   - Использовать краткое описание (до 50-72 символов для первой строки)
   - Описание должно быть на русском языке (если проект на русском)
   - Описание должно четко отражать суть изменений
   - Использовать повелительное наклонение: "Добавить", "Исправить", "Обновить", "Удалить"

2. **Примеры правильных сообщений коммита:**
   ```
   ✅ Добавить фильтр по ЦФО в таблице заявок
   ✅ Исправить ошибку валидации email
   ✅ Обновить структуру компонентов по страницам
   ✅ Удалить неиспользуемый компонент Sidebar
   ✅ Реорганизовать компоненты в папки _components
   ```

3. **Примеры неправильных сообщений:**
   ```
   ❌ fix
   ❌ изменения
   ❌ обновление
   ❌ исправления и улучшения
   ❌ много разных изменений в разных файлах
   ```

4. **Структура коммита:**
   - Первая строка: краткое описание (обязательно)
   - Вторая строка: пустая (опционально)
   - Третья строка и далее: детальное описание (опционально, если нужно)

5. **Пример с детальным описанием:**
   ```
   Реорганизовать компоненты по страницам
   
   - Переместить все компоненты из components/ в app/*/_components/
   - Обновить импорты во всех page.tsx файлах
   - Создать структуру папок для каждой страницы
   ```

6. **Когда пользователь просит сделать коммит:**
   - Автоматически создать краткое описание на основе изменений
   - Если изменений много - использовать общее описание с ключевыми изменениями
   - НЕ использовать автоматические сообщения типа "Update" или "Changes"

7. **Команды для коммита:**
   ```bash
   # Правильный формат
   git add .
   git commit -m "Краткое описание изменений"
   git push
   
   # Или с детальным описанием
   git commit -m "Краткое описание" -m "Детальное описание изменений"
   ```

8. **Если пользователь не указал описание:**
   - Проанализировать изменения (git status, git diff)
   - Создать краткое описание на основе изменений
   - Спросить подтверждение у пользователя перед коммитом (если описание неочевидно)

**ВАЖНО:** 
- Всегда использовать краткие и понятные описания коммитов
- Описание должно быть информативным и отражать суть изменений
- Избегать общих фраз типа "обновление" или "изменения"
- Использовать русский язык для описаний (если проект на русском)
