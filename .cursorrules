# Правила для Cursor AI

## Деплой на сервер
Когда пользователь упоминает "деплой", "deploy", "опубликовать", "публикация", "выложить на сервер" или похожие фразы, необходимо автоматически выполнить скрипт деплоя:

1. Выполнить PowerShell скрипт `scripts/deploy-simple.ps1` из корня проекта
2. Скрипт автоматически:
   - Соберет Docker образы (frontend, backend)
   - Сохранит их в tar файлы
   - Скопирует образы и `docker-compose.yml` на сервер (devops@10.123.48.62)
   - Обновит контейнеры на сервере

**ВАЖНО:** При деплое обязательно копировать обновленный `docker-compose.yml` на сервер, чтобы конфигурация сервисов была актуальной.

**КРИТИЧЕСКИ ВАЖНО:** При деплое НИКОГДА не выполнять коммит (`git commit`) и пуш (`git push`) изменений в Git, если пользователь явно не просит об этом. Деплой выполняется только через скрипт, без изменений в репозитории. Даже если есть незакоммиченные изменения, их НЕ нужно коммитить и пушить автоматически при деплое.

Команда для выполнения:
```powershell
.\scripts\deploy-simple.ps1
```

Не нужно спрашивать подтверждение - просто выполнить скрипт при упоминании деплоя.

## Запуск сервисов
Когда пользователь просит запустить сервис (фронтенд, бэкенд или оба), необходимо автоматически:

1. **Проверить и остановить локальные процессы:**
   - Проверить наличие запущенных Java процессов (для бэкенда)
   - Проверить наличие запущенных Node.js процессов (для фронтенда)
   - Остановить найденные процессы перед запуском

2. **Проверить и остановить Docker контейнеры:**
   - Проверить статус контейнеров через `docker compose ps`
   - Остановить и удалить существующие контейнеры через `docker compose stop` и `docker compose rm -f`
   - Это нужно делать для всех сервисов (frontend, backend, postgres)

3. **Запустить сервисы:**
   - После очистки запустить нужные сервисы через `docker compose up -d` или локально, в зависимости от запроса пользователя

Примеры фраз, которые должны триггерить это правило:
- "запусти сервис"
- "запусти бэкенд"
- "запусти фронтенд"
- "запусти локально"
- "запусти в докере"
- "перезапусти сервис"
- "перезапусти бэкенд"
- и похожие запросы

Не нужно спрашивать подтверждение - автоматически проверять и останавливать существующие процессы/контейнеры перед запуском.

## Локальный запуск без Docker

Когда пользователь просит запустить сервисы локально без Docker ("запусти локально без докера", "запусти без docker" и т.д.), необходимо:

### Подготовка окружения

1. **Для фронтенда:**
   - **macOS (с nvm):** Загрузить nvm: `source ~/.nvm/nvm.sh` (если npm не в PATH)
   - **Windows:** Убедиться, что Node.js установлен и доступен в PATH
   - Проверить npm: `npm --version` (работает на обеих платформах)

2. **Для бэкенда:**
   - **macOS/Linux:** Проверить Maven: `which mvn` или `mvn --version`
   - **Windows:** Проверить Maven: `where mvn` или `mvn --version`
   - Убедиться, что Java 17+ установлена: `java -version` (работает на всех платформах)

### Запуск PostgreSQL

PostgreSQL должен быть запущен в Docker (инфраструктура):
```bash
docker compose up -d postgres
```

### Запуск фронтенда

1. **Остановить существующие процессы:**
   - **macOS/Linux:**
     ```bash
     pkill -f "next dev" || true
     kill -9 $(lsof -ti:3000) 2>/dev/null || true
     ```
   - **Windows (PowerShell):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*node*" -and $_.CommandLine -like "*next dev*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 3000 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```
   - **Windows (CMD):**
     ```cmd
     taskkill /F /IM node.exe /FI "WINDOWTITLE eq *next dev*" 2>nul
     for /f "tokens=5" %a in ('netstat -aon ^| findstr :3000') do taskkill /F /PID %a 2>nul
     ```

2. **Запустить фронтенд:**
   ```bash
   cd frontend
   npm run dev
   ```
   - Фронтенд будет доступен на http://localhost:3000
   - Скрипты в `package.json` используют стандартные команды (`next dev`), которые работают на Mac и Windows

### Запуск бэкенда

1. **Остановить существующие процессы:**
   - **macOS/Linux:**
     ```bash
     pkill -f "spring-boot:run" || true
     kill -9 $(lsof -ti:8080) 2>/dev/null || true
     ```
   - **Windows (PowerShell):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*java*" -and $_.CommandLine -like "*spring-boot*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 8080 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```
   - **Windows (CMD):**
     ```cmd
     taskkill /F /IM java.exe /FI "WINDOWTITLE eq *spring-boot*" 2>nul
     for /f "tokens=5" %a in ('netstat -aon ^| findstr :8080') do taskkill /F /PID %a 2>nul
     ```

2. **Запустить бэкенд:**
   ```bash
   cd backend
   mvn spring-boot:run
   ```
   - Бэкенд будет доступен на http://localhost:8080/api
   - Health check: http://localhost:8080/api/health
   - Команда `mvn spring-boot:run` работает одинаково на всех платформах

### Проверка статуса

После запуска проверить:
- **Фронтенд:**
  - macOS/Linux: `curl http://localhost:3000` (ожидается HTTP 307 или 200)
  - Windows: `curl http://localhost:3000` или `Invoke-WebRequest http://localhost:3000` (PowerShell)
- **Бэкенд:**
  - macOS/Linux: `curl http://localhost:8080/api/health` (ожидается `{"service":"uzproc-backend","status":"UP"}`)
  - Windows: `curl http://localhost:8080/api/health` или `Invoke-WebRequest http://localhost:8080/api/health` (PowerShell)

### Важные замечания

- **npm должен быть в PATH:**
  - macOS: настроено через `.bash_profile` и `.zshrc` для автоматической загрузки nvm
  - Windows: Node.js должен быть установлен и добавлен в PATH системы (обычно делается автоматически при установке)
- PostgreSQL запускается в Docker, так как это инфраструктура (команда `docker compose up -d postgres` работает одинаково на всех платформах)
- При перезапуске всегда останавливать старые процессы перед запуском новых (использовать соответствующие команды для вашей ОС)
- Запускать сервисы в фоновом режиме (`is_background: true`) или с перенаправлением вывода для логирования
- На Windows рекомендуется использовать PowerShell для более удобной работы с процессами и портами

## Создание скриптов
НЕ создавать скрипты (shell, PowerShell, bash и т.д.) автоматически, если пользователь явно не запросил создание скрипта. Создавать скрипты только когда пользователь явно просит:
- "создай скрипт"
- "напиши скрипт"
- "сделай скрипт"
- "автоматизируй через скрипт"
- или похожие явные запросы

Если задача может быть решена без скрипта (например, через прямые команды или изменения в коде), не предлагать и не создавать скрипты.

## Документация
Всю документацию (README.md, инструкции, руководства, API документацию и т.д.) необходимо хранить в папке `docs` в корне проекта. 

- README файлы для отдельных модулей (например, `backend/README.md`, `frontend/README.md`) можно оставлять в соответствующих папках
- Общую документацию проекта, инструкции по развертыванию, архитектурные решения и другую проектную документацию размещать в `docs/`
- При создании новой документации предлагать размещение в `docs/`, если это не специфичный README для модуля

## Добавление новых полей и парсинг Excel

При добавлении новых полей в сущность `PurchaseRequest` и их парсинга из Excel файлов, **ОБЯЗАТЕЛЬНО** нужно:

1. **Изучить существующие поля и их парсинг:**
   - Посмотреть, как парсятся другие опциональные поля (например, `cfo`, `name`, `title`, `innerId`) в методе `parsePurchaseRequestRow` класса `ExcelLoadService`
   - Использовать аналогичную логику и структуру кода
   - Следовать тем же паттернам и стилю кода

2. **Добавить константу для названия колонки:**
   - Добавить `private static final String NEW_FIELD_COLUMN = "Название колонки в Excel";` в начало класса `ExcelLoadService`
   - Использовать точное название колонки из Excel файла

3. **Найти колонку в заголовке:**
   - Использовать `findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN)` для поиска колонки
   - Если колонка может иметь альтернативные названия, добавить проверки с `findColumnIndex` для каждого варианта
   - Добавить логирование, если колонка не найдена (как для других полей)

4. **Парсинг значения:**
   - Для строковых полей: использовать `getCellValueAsString(cell)` и проверку на `null` и пустоту
   - Для булевых полей: использовать `parseBooleanCell(cell)` и проверку на `null`
   - Для числовых полей: использовать соответствующие методы парсинга (`parseLongCell`, `parseDateCell` и т.д.)
   - Следовать той же структуре проверок, что и для других полей

5. **Обновление существующих записей:**
   - Добавить логику обновления нового поля в метод `updatePurchaseRequestFields`
   - Использовать тот же паттерн проверки на изменения, что и для других полей
   - Добавить логирование обновлений

6. **Пример структуры для опционального строкового поля:**
   ```java
   // В методе loadPurchaseRequestsFromExcel:
   Integer newFieldColumnIndex = findColumnIndex(columnIndexMap, NEW_FIELD_COLUMN);
   
   // В методе parsePurchaseRequestRow:
   if (newFieldColumnIndex != null) {
       Cell newFieldCell = row.getCell(newFieldColumnIndex);
       String newField = getCellValueAsString(newFieldCell);
       if (newField != null && !newField.trim().isEmpty()) {
           pr.setNewField(newField.trim());
       }
   }
   
   // В методе updatePurchaseRequestFields:
   if (newData.getNewField() != null && !newData.getNewField().trim().isEmpty()) {
       if (existing.getNewField() == null || !existing.getNewField().equals(newData.getNewField())) {
           existing.setNewField(newData.getNewField());
           updated = true;
           logger.debug("Updated newField for request {}: {}", existing.getIdPurchaseRequest(), newData.getNewField());
       }
   }
   ```

7. **Для булевых полей с обратной логикой:**
   - Если колонка называется "Не требуется..." или имеет обратную логику, проверить название колонки
   - Передать название колонки в метод `parsePurchaseRequestRow` как дополнительный параметр
   - Инвертировать логику парсинга, если необходимо

**ВАЖНО:** Всегда смотреть на существующие поля и делать аналогично. Не изобретать новые подходы, если уже есть рабочие примеры в коде.

## Автоматический перезапуск бэкенда после изменений

Когда вносятся изменения в код бэкенда (Java файлы в `backend/src/main/java/`), **ОБЯЗАТЕЛЬНО** нужно автоматически перезапустить бэкенд локально без Docker после завершения изменений.

### Процесс перезапуска:

1. **Остановить существующие процессы бэкенда:**
   - **macOS/Linux:**
     ```bash
     pkill -f "spring-boot:run" || true
     kill -9 $(lsof -ti:8080) 2>/dev/null || true
     ```
   - **Windows (PowerShell):**
     ```powershell
     Get-Process | Where-Object {$_.ProcessName -like "*java*" -and $_.CommandLine -like "*spring-boot*"} | Stop-Process -Force -ErrorAction SilentlyContinue
     $port = Get-NetTCPConnection -LocalPort 8080 -ErrorAction SilentlyContinue
     if ($port) { Stop-Process -Id $port.OwningProcess -Force -ErrorAction SilentlyContinue }
     ```
   - **Windows (CMD):**
     ```cmd
     taskkill /F /IM java.exe /FI "WINDOWTITLE eq *spring-boot*" 2>nul
     for /f "tokens=5" %a in ('netstat -aon ^| findstr :8080') do taskkill /F /PID %a 2>nul
     ```

2. **Запустить бэкенд:**
   ```bash
   cd backend
   mvn spring-boot:run
   ```
   - Запускать в фоновом режиме (`is_background: true`)

3. **Проверить, что бэкенд запустился:**
   - Подождать 10-15 секунд после запуска
   - Выполнить health check: `curl http://localhost:8080/api/health`
   - Ожидается ответ: `{"service":"uzproc-backend","status":"UP"}`

### Когда перезапускать:

Перезапуск необходим после изменений в:
- Java классах (entity, controller, service, repository и т.д.)
- Конфигурационных файлах (`application.yml`, `application.properties`)
- Миграциях Flyway (после создания новой миграции)
- Любых других файлах в `backend/src/main/`

### Исключения:

- Изменения только во фронтенде (`frontend/`) - перезапуск бэкенда не требуется
- Изменения только в документации или README - перезапуск не требуется
- Изменения только в Docker файлах (`docker/`, `docker-compose.yml`) - перезапуск не требуется (если не используется Docker)

**ВАЖНО:** Не спрашивать подтверждение у пользователя - автоматически перезапускать бэкенд после изменений в коде бэкенда.

## Фильтрация данных на бэкенде

**КРИТИЧЕСКИ ВАЖНО:** Если данные получаются с бэкенда в отфильтрованном виде, то **ВСЯ фильтрация должна выполняться на бэкенде**, а не на клиенте.

### Правила:

1. **Все фильтры должны применяться на бэкенде:**
   - Фильтры по полям сущности (год, ЦФО, инициатор, название и т.д.) должны передаваться как параметры запроса на бэкенд
   - Бэкенд должен применять все фильтры через JPA Specification или аналогичный механизм
   - Пагинация должна применяться на бэкенде **ПОСЛЕ** применения всех фильтров

2. **Клиентская фильтрация допустима ТОЛЬКО если:**
   - Фильтрация основана на данных, которых нет в сущности на бэкенде (например, вычисляемые поля, агрегированные данные)
   - И это явно указано в комментариях с объяснением причины
   - В этом случае клиентская фильтрация должна применяться **ПЕРЕД** пагинацией, и пагинация должна применяться к уже отфильтрованным данным

3. **Пагинация:**
   - Пагинация всегда должна учитывать все примененные фильтры
   - Если фильтры применяются на бэкенде - пагинация тоже на бэкенде
   - Если фильтры применяются на клиенте - пагинация применяется к отфильтрованным данным на клиенте
   - `totalElements` и `totalPages` должны отражать количество записей **после** применения всех фильтров

4. **Множественный выбор:**
   - Для множественного выбора (например, несколько ЦФО) использовать массив параметров или список значений
   - На бэкенде использовать `IN` запрос или `OR` условия для множественного выбора

5. **Проверка:**
   - При реализации фильтрации всегда проверять, что пагинация учитывает все фильтры
   - Убедиться, что `totalElements` соответствует количеству отфильтрованных записей, а не всех записей в базе

**Пример правильной реализации:**
- Фронтенд передает все параметры фильтрации на бэкенд
- Бэкенд применяет все фильтры через Specification
- Бэкенд применяет пагинацию к отфильтрованным данным
- Бэкенд возвращает `Page` с правильными `totalElements` и `totalPages`
- Фронтенд использует данные напрямую без дополнительной фильтрации

